package me.saket.dank.notifs;

import static me.saket.dank.utils.RxUtils.doNothingCompletable;

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.support.annotation.CheckResult;
import android.support.v4.app.RemoteInput;
import android.widget.Toast;

import com.squareup.moshi.Moshi;

import net.dean.jraw.models.Message;

import java.util.ArrayList;
import java.util.List;

import io.reactivex.Completable;
import io.reactivex.Single;
import me.saket.dank.R;
import me.saket.dank.di.Dank;
import me.saket.dank.ui.user.messages.InboxActivity;
import timber.log.Timber;

/**
 * Receives actions made on unread message notifications, generated by {@link MessagesNotificationManager}
 * and delegates them to {@link NotificationActionsJobService},
 */
public class NotificationActionReceiver extends BroadcastReceiver {

  public static final String KEY_DIRECT_REPLY_MESSAGE = "me.saket.dank.directReplyMessage";
  private static final String INTENT_KEY_MESSAGE_JSON = "me.saket.dank.message";
  private static final String INTENT_KEY_MESSAGE_ID_LIST = "me.saket.dank.messageIdList";
  private static final String INTENT_KEY_MESSAGE_ARRAY_JSON = "me.saket.dank.messageArrayJson";

  private static final String ACTION_DIRECT_REPLY = "quickReply";
  private static final String ACTION_MARK_AS_READ = "markAsRead";
  private static final String ACTION_MARK_ALL_AS_READ = "markAllAsRead";
  private static final String ACTION_MARK_AS_SEEN = "markAllAsSeen";
  private static final String ACTION_MARK_AS_SEEN_AND_OPEN_INBOX = "markAsSeenAndOpenInbox";

  @CheckResult
  public static Intent createDirectReplyIntent(Context context, Message replyToMessage, Moshi moshi, int notificationId) {
    if (notificationId == -1 || replyToMessage == null) {
      throw new AssertionError();
    }

    Intent intent = new Intent(context, NotificationActionReceiver.class);
    intent.setAction(ACTION_DIRECT_REPLY);
    intent.putExtra(INTENT_KEY_MESSAGE_JSON, moshi.adapter(Message.class).toJson(replyToMessage));
    return intent;
  }

  @CheckResult
  public static Intent createMarkAsReadIntent(Context context, Moshi moshi, Message... messages) {
    if (messages.length == 0) {
      throw new AssertionError();
    }

    Intent intent = new Intent(context, NotificationActionReceiver.class);
    intent.setAction(ACTION_MARK_AS_READ);
    intent.putExtra(INTENT_KEY_MESSAGE_ARRAY_JSON, moshi.adapter(Message[].class).toJson(messages));
    return intent;
  }

  /**
   * @param messagesToMarkAsRead Used for marking their notifications as "seen".
   */
  @CheckResult
  public static Intent createMarkAllAsReadIntent(Context context, List<Message> messagesToMarkAsRead) {
    ArrayList<String> messageIdsToMarkAsRead = new ArrayList<>(messagesToMarkAsRead.size());
    for (Message message : messagesToMarkAsRead) {
      messageIdsToMarkAsRead.add(message.getId());
    }

    // Don't need to store the message objects because marking all as read doesn't require any Message param.

    Intent intent = new Intent(context, NotificationActionReceiver.class);
    intent.setAction(ACTION_MARK_ALL_AS_READ);
    intent.putStringArrayListExtra(INTENT_KEY_MESSAGE_ID_LIST, messageIdsToMarkAsRead);
    return intent;
  }

  /**
   * Gets called when an individual notification is dismissed.
   */
  @CheckResult
  public static Intent createMarkAsSeenIntent(Context context, Message messageToMarkAsSeen) {
    ArrayList<Message> singleList = new ArrayList<>(1);
    singleList.add(messageToMarkAsSeen);
    return createMarkAllAsSeenIntent(context, singleList);
  }

  /**
   * Gets called when the entire bundled notification is dismissed.
   */
  @CheckResult
  public static Intent createMarkAllAsSeenIntent(Context context, List<Message> messagesToMarkAsSeen) {
    ArrayList<String> messageIdsToMarkAsSeen = new ArrayList<>(messagesToMarkAsSeen.size());
    for (Message message : messagesToMarkAsSeen) {
      messageIdsToMarkAsSeen.add(message.getId());
    }

    Intent intent = new Intent(context, NotificationActionReceiver.class);
    intent.setAction(ACTION_MARK_AS_SEEN);
    intent.putStringArrayListExtra(INTENT_KEY_MESSAGE_ID_LIST, messageIdsToMarkAsSeen);
    return intent;
  }

  /**
   * Mark all unread messages as seen and then open {@link InboxActivity}.
   */
  @CheckResult
  public static Intent createMarkAllSeenAndOpenInboxIntent(Context context, List<Message> messagesToMarkAsSeen) {
    ArrayList<String> messageIdsToMarkAsSeen = new ArrayList<>(messagesToMarkAsSeen.size());
    for (Message message : messagesToMarkAsSeen) {
      messageIdsToMarkAsSeen.add(message.getId());
    }

    return new Intent(context, NotificationActionReceiver.class)
        .setAction(ACTION_MARK_AS_SEEN_AND_OPEN_INBOX)
        .putStringArrayListExtra(INTENT_KEY_MESSAGE_ID_LIST, messageIdsToMarkAsSeen);
  }

  /**
   * Mark <var>unreadMessage</var> as seen and then open {@link InboxActivity}.
   */
  @CheckResult
  public static Intent createMarkAsSeenAndOpenInboxIntent(Context context, Message unreadMessage) {
    ArrayList<Message> singleList = new ArrayList<>(1);
    singleList.add(unreadMessage);
    return createMarkAllSeenAndOpenInboxIntent(context, singleList);
  }

  @Override
  public void onReceive(Context context, Intent intent) {
    switch (intent.getAction()) {
      case ACTION_DIRECT_REPLY: {
        parseMessage(intent.getStringExtra(INTENT_KEY_MESSAGE_JSON))
            .flatMapCompletable(message -> {
              // Note: dismiss notification after calling CheckUnreadMessagesJobService.refreshNotifications()
              // so that the summary notif gets removed first. Otherwise, the summary notif goes into a gray
              // color "disabled" state that is visible for a short time if there are no more individual notifs
              // available. CheckUnreadMessagesJobService.refreshNotifications() will dismiss all notifs if no
              // unseen/unread messages are present, so the summary gets removed too.
              return Completable
                  .fromAction(() -> {
                    Bundle directReplyResult = RemoteInput.getResultsFromIntent(intent);
                    String replyText = directReplyResult.getString(KEY_DIRECT_REPLY_MESSAGE);
                    NotificationActionsJobService.sendDirectReply(context, message, Dank.moshi(), replyText);
                  })
                  .andThen(Dank.messagesNotifManager().markMessageNotifAsSeen(message))
                  .andThen(Completable.fromAction(() -> NotificationActionsJobService.markAsRead(context, Dank.moshi(), message)))
                  .andThen(Completable.fromAction(() -> CheckUnreadMessagesJobService.refreshNotifications(context)))
                  .andThen(Dank.messagesNotifManager().dismissNotification(context, message));
            })
            .subscribe(doNothingCompletable(), error -> {
              Timber.e(error, "Couldn't send direct reply");
              Toast.makeText(context, R.string.common_unknown_error_message, Toast.LENGTH_LONG).show();
            });
        break;
      }

      case ACTION_MARK_AS_READ: {
        // Offload work to a service (because Receivers are destroyed immediately) and refresh
        // the notifs so that the summary notif gets canceled if no more notifs are present.
        parseMessageArray(intent.getStringExtra(INTENT_KEY_MESSAGE_ARRAY_JSON))
            .flatMapCompletable(messages -> Dank.messagesNotifManager()
                .markMessageNotifAsSeen(messages)
                .andThen(Completable.fromAction(() -> CheckUnreadMessagesJobService.refreshNotifications(context)))
                .andThen(Completable.fromAction(() -> NotificationActionsJobService.markAsRead(context, Dank.moshi(), messages)))
                .andThen(Dank.messagesNotifManager().dismissNotification(context, messages))
            )
            .subscribe();
        break;
      }

      case ACTION_MARK_ALL_AS_READ: {
        List<String> messageIdsToMarkAsRead = intent.getStringArrayListExtra(INTENT_KEY_MESSAGE_ID_LIST);
        Dank.messagesNotifManager()
            .markMessageNotifAsSeen(messageIdsToMarkAsRead)
            .andThen(Completable.fromAction(() -> CheckUnreadMessagesJobService.refreshNotifications(context)))
            .andThen(Completable.fromAction(() -> NotificationActionsJobService.markAllAsRead(context)))
            .subscribe();
        break;
      }

      case ACTION_MARK_AS_SEEN: {
        List<String> messageIdsToMarkAsSeen = intent.getStringArrayListExtra(INTENT_KEY_MESSAGE_ID_LIST);
        Dank.messagesNotifManager()
            .markMessageNotifAsSeen(messageIdsToMarkAsSeen)
            .subscribe();
        // This action gets called only when all the notifs are dismissed, so we don't need to refresh the notif again.
        break;
      }

      case ACTION_MARK_AS_SEEN_AND_OPEN_INBOX: {
        List<String> messageIdsToMarkAsSeen = intent.getStringArrayListExtra(INTENT_KEY_MESSAGE_ID_LIST);
        Dank.messagesNotifManager()
            .markMessageNotifAsSeen(messageIdsToMarkAsSeen)
            .subscribe(() -> {
              Intent inboxIntent = InboxActivity.createStartIntent(context, null);
              inboxIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
              context.startActivity(inboxIntent);
            });
        // This action is also performed only when a notification is tapped, where it gets dismissed. So refreshing notifs isn't required.
        break;
      }

      default:
        throw new UnsupportedOperationException("Unknown action: " + intent.getAction());
    }
  }

  @CheckResult
  private Single<Message> parseMessage(String messageJson) {
    return Single.fromCallable(() -> Dank.moshi().adapter(Message.class).fromJson(messageJson));
  }

  @CheckResult
  private Single<Message[]> parseMessageArray(String messageArrayJson) {
    return Single.fromCallable(() -> Dank.moshi().adapter(Message[].class).fromJson(messageArrayJson));
  }

}
